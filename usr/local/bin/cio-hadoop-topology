#!/usr/bin/env python

# Copyright (c) 2016 Coho Data Inc.
# The subject matter distributed under this license is or is based on
# information and material generated by Coho Data Inc. It may only be
# acquired, used, modified and distributed under the terms of the Coho
# Data Compute Cluster License v1.0.  Except as permitted in the Coho
# Data Compute Cluster License v1.0, all other rights are reserved in
# any copyright or other similar rights which may exist. Execution of
# software distributed under this Coho Data Compute Cluster License
# v1.0 may cause you to acquire third-party software (as described in
# the accompanying documentation) and you agree (a) to comply with the
# applicable licenses thereunder and (b) that Coho is not responsible
# in any way for your compliance or non-compliance with the applicable
# third-party licenses or the consequences of your being subject to
# said licenses or your compliance or non-compliance.

"""cio-hadoop-topology: given a list of IP addresses, returns the racks
                        on which they are located.

This script relies on the following external state:

A file named /tmp/COHO_TENANT which contains the name of the tenant the
resourcemanager is contained in.  Used to find an IP inside of the appropriate
tenant network.

A file named /tmp/COHO_CLUSTER_UUID which contains the name of the cluster the
resourcemanager is a member of.  Used as the default rack when an address cannot
be found in the topology directory.
"""
from __future__ import print_function

import os
import json
from sys import stdout, stderr
from contextlib import contextmanager
from tempfile import mkdtemp
from subprocess import check_output, CalledProcessError
import requests
import base64

def warn(*args):
    """Print a warning message to stderr"""
    print('WARN: ', *args, file=stderr)

def readenv(var, default=None):
    """Reads the value of an environment variable from a well-known tmp file"""
    path = os.path.join('/tmp', var)
    try:
        return open(path).read().strip()
    except IOError as e:
        warn('Failed to read env var from %s: %s' % (path, str(e)))
        return default

def kvget(path):
    """Perform a recursive GET on the consul KV service at <path>"""
    url = 'http://127.0.0.1:8500/v1/kv/%s?stale&recurse' % path
    try:
        return requests.get(url).json()
    except (requests.exceptions.RequestException, ValueError) as e:
        warn('KV GET %s failed %s' % (url, str(e)))
        return None

def unmarshal(entry):
    """Returns the (path, ctime) pair encapsulated in the KV <entry>"""
    path = entry['Key']
    ctime = 0
    try:
        ctime = int(base64.decodestring(entry['Value']))
    except ValueError as e:
        warn('Failed to decode ctime from %s: %s' % (str(entry), str(e)))
    return path, ctime

def readtopology():
    """Reads the topology map for the tenant out of the filesystem and
    returns a mapping from IP => RACK

    Topology information is encoded as a tree in the consul KV store.
    For example:

    /.coho/tenant0/hdfs/topology/cluster0/node0/ip1
                                            .../ip2
                                            .../ip3
                                      .../node1/ip4
                                      .../node2/ip5
       .../tenant1/hdfs/topology/cluster0/node0/ip6
                                            .../ip7


    In the above, containers with IPs ip1, ip2, ip3 are running in
    the tenant0 namespace on node0 and are identified by rack location:
    /cluster0/node0

    Container with IP ip4 is running in the tenant0 namespace on node1 and
    is identified by rack location: /cluster0/node1

    Container with IP ip5 is running in the tenant0 namespace on node2 and
    is identified by rack location: /cluster0/node2

    Containers with IPs ip6, ip7 are running in the tenant1 namespace on
    node0 and are identified by rack location: /cluster0/node0
    """
    withtopo = readenv('WITH_COHO_HADOOP_TOPOLOGY', None)
    if withtopo is None or withtopo != 'true':
        return {}

    tenant = readenv('COHO_TENANT', None)
    if tenant is None:
        warn('COHO_TENANT ENV is not specified, cannot read topology map')
        return {}

    topopath = 'coho/%s/hdfs/topology' % tenant
    out = kvget(topopath)
    if out is None:
        # we couldn't read the topology mapping
        return {}

    # interpret the topology mapping
    top = {}
    for entry in out:
        path, ctime = unmarshal(entry)
        dirpath = path[len(topopath):]
        parts = dirpath.split('/')
        if len(parts) != 4:
            # we are only interested in entries of the following form
            # /cluster/node/ip
            continue
        _, cluster, node, ip = parts
        rack = os.path.join('/', cluster, node)
        # IP addresses can be reused; disambiguate rack location by ctime
        if ip in top:
            top[ip].append((ctime, rack))
        else:
            top[ip] = [(ctime, rack)]
    return top

def defaultrack():
    return os.path.join('/', readenv('COHO_CLUSTER_UUID', 'default-rack'))

def getrack(addr, topology):
    racks = topology.get(addr, None)
    if racks is None:
        return defaultrack()
    else:
        # sort locations by mtime and return the most recent
        racks = sorted(racks, key=lambda x:x[0], reverse=True)
        return next((r[1] for r in racks))

def main(addrs):
    topo = readtopology()
    racks = [getrack(addr, topo) for addr in addrs]
    print(' '.join(racks), file=stdout)

if __name__ == '__main__':
    from optparse import OptionParser
    parser = OptionParser(usage='usage: %prog [IP]...')
    (options, args) = parser.parse_args()
    main(args)
